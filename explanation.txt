**Back-end app**

1. run the script "bootstrap.sh" by typing "(project_dir)$ .bootstrap.sh" on shell.
   a. "bootstrap.sh" run functions from "scripts/functions.sh".
      1. "scripts/functions.sh" run "docker-compose stop" command to clear out old containers.
      2. "scripts/functions.sh" run "docker-compose build" command to setup new containers
         based on "Dockerfile" and "docker-compose.yml".
         a. "Dockerfile"
            1. install python, run updates for packages and install shellcheck.
            2. run "install_dependencies.sh".
               a. "install_dependencies.sh" install all the required dependencies (packages)
                   listed in "requirements.txt".
         b. "docker-compose.yml"
            1. create "app" container that uses the configuration of the corresponding service
               name "app" from the "docker/docker-compose.common.yml" file.
               a. "docker/docker-compose.common.yml" runs the "scripts/start_app.sh" that
                  starts the python application.


** "manage.py" and files under the "na_wai_backend" directory are generated by running the
   "django-admin startproject na_wai_backend" command. 
   - once the command is run, a "na_wai_backend" folder will be created in the current
     directory and inside the "na_wai_backend" folder with have a "manage.py" file and a
     "na_wai_backend" folder that contains the "__init__.py", "settings.py", "urls.py" and
     "wsgi.py" files.
   - cut and paste everything from the parent "na_wai_backend" folder to the project directory
     so that "Dockerfile", "manage.py" and the "na_wai_backend" sub-folder are in the same
     directory.
     - delete the empty "na_wai_backend" folder"

*************************************************************************************************

Unit Test:
1. bash into the container:
   (project_dir)$ docker-compose run app bash
2. To see which file needs to write test for and the percentage of coverage:
   app# scripts/test_app.sh
   app# coverage html
3. Look at the result on web page:
   (project_dir)$ open htmlcov/index.html
4. To run test on one module:
   app# ./manage.py test <module_name>.tests
5. To run test on one test case:
   app# ./manage.py test <module_name>.tests.<TestCaseName>

Linter Test:
1. bash into the container:
   (project_dir)$ docker-compose run app bash
2. Run test:
   app# pycodestyle --exclude=docs,migrations .
   app# pylint --load-plugins pylint_django *

To run all the tests above together at once:
(project_dir)$ docker-compose run app scripts/test_app.sh

-----------------------------------------------------------------------------------------------


**Front-end app**

1. run the script "bootstrap.sh" by typing "(project_dir)$ .bootstrap.sh" on shell.
   a. "bootstrap.sh" run functions from "scripts/functions.sh".
      1. "scripts/functions.sh" run "docker-compose stop" command to clear out old containers.
      2. "scripts/functions.sh" run "docker-compose build" command to setup new containers
         based on "Dockerfile" and "docker-compose.yml".
         a. "Dockerfile"
            1. install node, run updates for packages and install shellcheck.
            2. run "install_dependencies.sh".
               a. install chrome for unit testing.
               b. npm install
                  1. run code in "package.json"
                     a. define "ng", "start", "build", "test", "lint", "e2e" and "doc" commands.
                     b. install packages listed under dependencies.
                  2. "package-lock.json" is automatically generated based on version requirement
                     listed in "package.json".  "package-lock.json" restrict the exact version
                     of packages can be installed.
         b. "docker-compose.yml"
             1. create "app" container that uses the configuration of the corresponding
                service name "app" from the "docker/docker-compose.common.yml" file.
                a. "app" service in "docker/docker-compose.common.yml"
                   1. runs "scripts/start_app.sh"
                      a. "scripts/start_app.sh" run the "start" command stated in the
                         "package.json" file that starts the Angular application.
                   2. uses environment variables defined in "development.env".
             2. create "backend" container that uses the configuration of the corresponding
                service name "backend" from the "docker/docker-compose.common.yml" file.
                a. "backend" service in "docker/docker-compose.common.yml" is extended from the
                   "app" service in "backend/docker/docker-compose.common.yml" that belongs to
                   another repo.
             3. create "test-server" container that uses the configuration of the corresponding
                service name "test-server" from the "docker/docker-compose.common.yml" file.
                a. "test-server" service in "docker/docker-compose.common.yml" build image
                   "selenium/hub".
             4. create "test-node" container that uses the configuration of the corresponding
                service name "test-node" from the "docker/docker-compose.common.yml" file.
                a. "test-node" service in "docker/docker-compose.common.yml"
                   1. build image "selenium/node-chrome".
                   2. uses environment variables defined in "development.test-node.env".
             5. create "test-app" container that uses the configuration of "app" service
                from the "docker/docker-compose.common.yml" file.
2. for testing, run "(project_dir)$ docker-compose run app scripts/test_app.sh" on shell.
   a. "scripts/test_app.sh" run the commands stated in the "package.json" file.
      1. "lint" checks the coding style.
      2. "test" checks the code coverage of the tests.
      3. "e2" checks the end-to-end test.
3. for documenation, run "(project_dir)$ docker-compose run app scripts/build_documentation.sh"
   on shell.
   a. "scripts/build_documentation.sh" runs the "doc" commands stated in the "package.json" file
      that checks the documentation coverage.


** In order to use "ng generate component <component_name>" to create a new component to the
   app, you can install "node" and "@angular/cli" on your host or install from your
   container.  To install from container, enter in bash mode in container by running
   "docker-compose run <container_name> bash", then run "npm run ng" to enable ng (angular)
   commands, then run ng generate command to create new component.

*************************************************************************************************

Documentation:
1. To generate a document that shows which file needs documentation and the percentage of coverage:
   (project_dir)$ docker-compose run app npm run doc
2. Open the documentation in web browser:
   (project_dir)$ open documentation/index.html
3. After documentation is added to all files, double check that the coverage is 100%:
   (project_dir)$ docker-compose run app npm run doc

Unit Test:
1. To see which file needs to write test for and the percentage of coverage:
   (project_dir)$ docker-compose run app npm run test
2. Look at the result in web browser:
   (project_dir)$ open coverage/index.html
3. Pull 'f' in front of 'describe' or 'it' to run only that specific test.
4. After unit test is added to all files, double check that no 'f' is put in front of any test.
   Run test again and make sure the coverage is 100%:
   (project_dir)$ docker-compose run app npm run test

e2e (end-to-end) Test:
(There's no way to see the coverage percentage for e2e test because there's no coverage
requirement for e2e test)
(project_dir)$ docker-compose run app npm run e2e

Linter Test:
(project_dir)$ docker-compose run app npm run lint

To run all the tests above together at once:
(project_dir)$ docker-compose run app scripts/test_app.sh
